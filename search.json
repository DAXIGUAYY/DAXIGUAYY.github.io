[{"title":"JavaScript","url":"/2022/07/10/Javascript%E5%9F%BA%E7%A1%80/","content":"<p>Js<br>1.prompt  浏览器输入弹出框  用户可以输入<br>ConsoLe.log浏览器控制台打印<br>alert 浏览器弹出框</p>\n<p>2.（声明变量）<br>var   age（变量名字）；<br>（赋值 存储内容）<br>age=18;<br>（输出结果）<br>console.log(age)<br>变量的初始化<br>var age =18;<br>console.log(age)<br>3.js的变量数据类型    是只有程序运行过程中，根据等号右边的值来确定  var num = 10;<br>js 变量的数据类型是可以变化的       所以不确定属于那种数据类型</p>\n<p>Number数字类型，包含 整数型和浮点型  如21 、 0.21Boolean布尔类型，如 true, false,   等价于 1 和 0；String字符串类型， 如”张三“， 注意咱们JS里面，字符串都带引号 ‘’ ,  “” ,单引号双引号都可，成对undefinedvar a; 声明了变量a ，但是没有给值，  此时  a 默认值为 undefinednullvar a = null ;  声明了变量 a 为空值BigIntBigInt 类型是JS中一个基础的数值类型，可表示任意精度的整数。Symbol符号（Symbols）类型是唯一且不可修改的原始值，并且可以用来作为对象的键(key)</p>\n<p>4.程序里数字前面加零，表示八进制<br>5.数字类型：前面加0x属于十六进制的数据类型<br>6.console.log(Number.Max_vaule) 最大值          console.log(Number.Min_vaule) 最小值     console.log(Number.Max_vaule *2)无穷大   - console.log(Number.Max_vaule *2  ) 无穷小   NaN 不是数字，非数字<br>7.isNaN 用来判断是否是数字    console.log(isNaN(1323)) 如果是数字则判断为FALSE 如果不是则为true<br>8.布尔值 FALSE代表0 TRUE代表0     </p>\n<ol start=\"9\">\n<li>console.log(undefined + ‘pink’)     // ‘undefinedpink’<br> console.log(undefined + 1) // NaN   // undefined 和数字相加 得到 NaN  / not a number</li>\n</ol>\n<p>// null 空值<br>console.log(null + ‘pink’) // nullpink<br>console.log(null + 1)   // 1</p>\n<p>console.log(true + ‘1’);      结果为 true1</p>\n<p>10.通过typeof 判断    变量属于哪种数据类型<br>11.<br>    变量值为null时 输出的结果为 Object<br> //<br>        var nul = null;<br>        console.log(typeof nul);</p>\n<p>特殊字符<br>\\n     换行符，n   是   newline   的意思<br>\\       斜杠   <br>&#39;       ‘   单引号<br>&quot;    ”双引号<br>\\t    tab  缩进<br>\\b    空白 退格</p>\n<p>12.<br>prompt 获取的数据是属于字符型<br>    // prompt 获取的数据是属于字符型<br>         var age =prompt(“请输入您的年龄”);<br>         console.log(age);<br>         console.log(typeof age);<br>         结果显示为字符型<br>13.<br>将数值或者布尔转换为字符型<br>  // 利用 ＋ 拼接法实现将布尔型转换为字符型 也叫隐式转换法<br>        console.log(bool + “”);</p>\n<p>14.将字符型转换为数字型<br>   var age = prompt(“请输入您的年龄”);<br>        // 1.使用parseInt(变量) 将字符型转换为数字型 得到的是整数<br>        console.log(parseInt(age));<br>        // parsrInt可以去掉单位<br>        console.log(parseInt(‘120px’));</p>\n<p>        // 2.使用parseFloat(变量) 可以取小数点 也叫浮点<br>        console.log(parseFloat(‘12.12’));<br>         // parsrFloat也可以去掉单位<br>         console.log(parseFloat(‘120px’))<br>转换为数字<br>  4. 隐式转化(自动将一种数据转换成另外一种数据类型)<br>        // 除了 + 号是进行拼接  ,其余的 - * / 都可以将字符串直接转换成数字型直接进行运算<br>        console.log(‘12’ - 1);<br>        console.log(‘10’ / 4);<br>        console.log(‘12’ * 3);</p>\n<pre><code>    console.log(2 &gt; &#39;1&#39;);  // true\n&#39;  &#39; , 0 , undefined, NaN , null      这五种 逻辑非 自动取反 隐式转换会自动将其转换为false\n</code></pre>\n<p>大于号 小于号 == 都具有转型点  </p>\n<ol start=\"15\">\n<li><p>% 取余   console.log( 4 % 2 )  余数为零    判断数字是否 被整除</p>\n</li>\n<li><p>浮点数不能拿来比较 </p>\n<p>// 浮点数精度问题 0.3000000004</p>\n<pre><code> // 1, 先将它转换为整数  再换算成浮点数\n var num = (0.1 * 10 + 0.2 * 10) / 10\n console.log(num)\n     // 2. .toFixed( 保留几位小数 ) \n var num2 = (0.1 + 0.2).toFixed(1)  // 转化成字符串类型\n console.log(num2);\n</code></pre>\n</li>\n</ol>\n<p>16.<br>递增运算符加减<br> var c = 10;<br>        c++; // 因为c++属于表达式 但是c++是先返回值 后加1 所以此时的c++为10 c为11<br>        var d = c++ + 2; // c为11 所以现在的c++ 值为11  所以结果为 13<br>        console.log(d);\n        </p>\n<p>        var e = 10;<br>        var f = e++ + ++e; // e++先返回值 再加一 所以此时的e++等于10  e等于11  ++e就等于12  所以结果为22<br>        console.log(f);<br>17.<br>运算符<br>        console.log( 3 == 5 ); //false      <br>        console.log( 10 == ‘10’); // true  == 默认会转换数据类型 会把字符串类型的转换为数字类型 只有值相等就可以<br>        console.log( 18 != 18 ); //false  不等于号<br>        console.log( 18 === 18 ); // true     全等于       两侧的值和数据类型必须全部都一模一样 结果才会是true</p>\n<p>18.<br>逻辑运算中断<br>&amp;&amp; 只要有一侧为假就为假<br>console.log(  3 &lt; 5 &amp;&amp; 3 &gt;2     )<br>如果第一个表达式的值为真，则返回表达式2<br>如果第一个表达式的值为假，则返回表达式1<br>只要碰到了假值(false)，就会短路，并返回该假值<br>console.log( 123 &amp;&amp; 456 );        // 456<br>console.log( 0 &amp;&amp; 456 );          // 0<br>console.log( 123 &amp;&amp; 456&amp;&amp; 789 );  // 789</p>\n<p>switch语句          // 表达式经常写变量<br>var num =1<br>switch(num){<br>case  vaule 1:<br>console.sole(‘1’)<br>break;<br>case  vaule 2:<br>console.sole(‘2’)<br>break;</p>\n<p>}<br>|| 只要有一侧为真 就为真<br>如果第一个表达式的值为真，则返回表达式1<br>如果第一个表达式的值为假，则返回表达式2<br>逻辑或  (只要碰到了真值(true)，就会短路，并返回该真值<br>console.log( 123 || 456 );         //  123<br>console.log( 0 ||  456 );          //  456<br>console.log( 123 || 456 || 789 );  //  123</p>\n<ol start=\"19\">\n<li>for循环<br>for ( 初始化变量; 条件表达式; 操作表达式  )<br>20 .while循环   当…..的时候    当条件表达式为true 就执行循环体代码   当….不等于的时候<br>var i =1<br>while (条件表达式) {<br>//  循环体代码<br>i++<br>}<br>continue  关键字 退出本次循环 (当次的循环)  继续执行剩余次数循环</li>\n</ol>\n<p>获取数组的长度   数组名.length<br>获取数组中的某一个(arr[  i  ])</p>\n<p>数组:<br>    var sum = 0<br>        var arr = [2, 6, 1, 7, 4]<br>        for (var i = 0; i &lt; arr.length; i++) {<br>            sum = sum + arr[ i ]<br>        }<br>        // 获取数组长度 数组名称.length<br>        console.log(sum);<br>arr.length = 10 说明里面有10个数<br> 往新数组里面加元素             newArr[newArr.length ] = arr [ i ]  (给数组连续追加元素的固定写法)</p>\n<p> // 交换两个变量<br>        var num1 = 20<br>        var num2 = 10;<br>        [num1, num2] = [num2, num1]<br>        console.log(num1, num2);<br>// 在[]和()前面加分号<br> //  ;[]<br> //  ;()</p>\n<p>翻转数组:<br> // 翻转数组  arr.reverse() 改变了原数组<br>        arr.reverse()<br>        console.log(arr);<br>不改变原数组,复制一份原数组 先复制再进行翻转<br>      var newArr = arr.slice().reverse<br>        console.log(newArr);<br>        console.log(arr);<br>求最大值: 定义一个 max变量  var max = arr[ 0 ]    现将数组的第一个变量存进去 再让其与其他元素比较</p>\n<p>函数:</p>\n<p>        function getMax(arr) {</p>\n<p>        }<br>        var res = getMax([5, 2, 99, 1000, 101, 67, 77])</p>\n<p> return 后面的代码不会执行  只能返回一个值<br>冒泡排序: 外层 n-1  内层 n -1 -i</p>\n<p>es6之前:作用域分为全局作用域和函数作用域<br>在函数内部没有声明直接赋值的变量也属于全局变量   num =10       全局变量任何一个作用域都可以使用<br>函数的形参也属于局部变量<br>全局作用域下的变量都挂载到window对象下面, window是窗口的意思,它是浏览器的顶级对象<br>从执行效率来看全局变量和局部变量<br>1.全局变量只有当浏览器关闭的时候才会销毁,比价浪费内存<br>2.局部变量 当我们的程序执行完才会销毁,比较节约内存</p>\n<p>Es6新增块级作用域   if{}  for{} 是一个语句,不是函数<br>if(ture) {<br>var num =123   // es5<br>let  num1 = 123  // es6<br>const num2 =123  // es6<br>]         //  用let和const声明的变量,因为存在块级作用域的关系,我们在外部不能访问</p>\n<p>作用域链 : (内部函数访问外部函数)  就近原则  如果当前函数没有变量,就去外面的那个函数寻找 </p>\n<p>预解析: js引擎会把js 里面所有带var 和 function的变量 提升到当前作用域在前面(提升到当前作用域最顶部)      面试题:  study/预解析案例<br>表达式声明 var fun  = function() {<br>}    fun()             如果是表达式声明的函数， 调用一定写在声明的下方</p>\n<p>对象:属性和方法的集合</p>\n<p>构造函数:  1.构造函数名字首字母必须大写  2.不需要写return也可以返回结果   3. 我们调用构造函数 必须使用 new  4. 我们只要new Star() 调用函数就创建一个对象 ldh  {}  5.构造函数里 属性和方法前面必须添加 this<br>通过构造函数创建对象的过程,也叫做对象的实例化      构造一个函数,相当于一个模板,通过它,我们可以创建一系列具有相同属性和方法的对象<br>new关键字执行过程:  1.在内存中创建了一个空对象  2. 让this指向这个对象 3.执行构造函数里面的代码,给这个对象添加属性和方法 4.返回这个新创的对象<br>遍历对象:( for 变量 in )</p>\n<p>Math对象<br> console.log(Math.min()); // 返回     min        infinity<br> console.log(Math.max()); // 返回     max       - infinity<br> console.log(Math.max(1, 23, ‘pink’))   //  如果有任意参数不能转换为数字 无论是最大值还是最小值,返回的都是 NaN</p>\n<p>如果想将一个数组传入进去:<br>Math.max()<br>var arr = [1,2,3,4,5,5,6]<br> console.log(Math.max(…arr));    //  …arr可以展开数组  es6属性</p>\n<p>随机 Math.random</p>\n<ol>\n<li>从1 到任意值的整数<br>parseInt(Math.random() * n + 1)</li>\n<li>从任意数开始 到任意数结束 (包含这两个数)</li>\n</ol>\n<p>日期 Date<br>1.var month = date.getMonth() + 1 月数需要加1<br>2.通过 valueOf()  getTime() 获得Date总的毫秒数(时间戳)<br>var date = new Date()<br>      1）  console.log(date.valueOf());<br>          2）    console.log(date.getTime());<br>3）var date1 = +new Date() // 不传参数表示从1970年1月1日到现在多少毫秒<br>4）var date2 = Date.now()   // H5 新增的 获得总的毫秒数<br> 检测是否是数组的方法</p>\n<ol>\n<li> A instanceof B (Array)        console.log(arr instanceof Array)  // true 是数组    (检测引用类型)</li>\n<li>Array.isArray(数组变量名)     console.log(Array.isArray(arr))  // 如果是数组, 返回true</li>\n</ol>\n<p>利用new Array()给数组添加元素<br>var arr = new Array(2) // 如果只传入一个参数 2 表示数组的长度为2<br>var arr2 = new Array(2, 4) // 如果传入多个参数 相当于  [2,4]</p>\n<p>检测数据类型:     </p>\n<ol>\n<li><p> A instanceof B </p>\n</li>\n<li><p>检测基本数据类型  typeof        返回数据类型是字符串表达         可以判断 undefined/ 数值 / 字符串 / 布尔值    </p>\n</li>\n<li><p>perfect最好的  Object.prototype.toString.call()</p>\n</li>\n<li><p>===          可以判断 undefined / null<br>push / unshift / pop / shift </p>\n</li>\n<li><p>push / unshift / pop / shift 都会改变原数组</p>\n</li>\n<li><p>push / unshift 是添加, 返回的是新数组的长度    push:数组的末尾 添加一个或者多个数组元素  unshift:在我们数组的开头 添加一个或者多个数组元素</p>\n</li>\n<li><p>push()/ unshift() / pop() / shift()  都会改变原数组          var res = arr.push(9, ‘orange’)    数组名.push</p>\n</li>\n</ol>\n<p>2.push(从后) / unshift(从前) 是添加, 返回的是新数组的长度<br>3.pop(最后一个) / shift(第一个) 是删除, 一次只删除一个, 不需要传参数. 返回的是被删除的元素. </p>\n<p>翻转数组: var arr = [1,2,1,4,4,5,6,7]      arr.reverse();    console.log(arr )</p>\n<p>数组排序（冒泡排序） 数组名.sort()<br>        var arr1 = [1, 4, 5, 6, 3, 0, 63, 35, 32, ]<br>        arr1.sort(function(a, b) {<br>            return a - b // a - b 是升序     a - b &gt; 0<br>        })<br>        console.log(arr1);<br>字符串属性 length<br>concat  拼接数组   var str = ‘123’            字符串方法<br>                          console.log(str.concat(‘456’));<br> substring(star,end)  截取字符串   取不到end        console.log(str1.substring(0, 3));<br>替换字符.replace(‘被替换的字符’,’要替换的字符’)<br>     slice()截取数组  splice()修改数组    MDN查找</p>\n<p>将数组转换为字符串<br>1.数组名.toSting()<br>2.join(分隔符)  数组名 .join(分隔符)      console.log(arr.join(‘ - ‘)  )</p>\n<p>将字符串转换为数组 split(‘分隔符’)  不改变元素组<br>字符串里面的分割符是什么样,split(‘)里面的分隔符就是什么样</p>\n<p>获取数组的索引号  ( 根据数组参数得到索引号)<br>1.indexOf(数组元素)    1)它只返回找到的第一个元素的索引号   console.log( arr.indexOf(‘blue’) )<br>如果想要略过第一个要查的值去查第二个  console.log( arr.indexOf(‘blue’ 索引号的第二个) )<br>2.lastIndexOf(数组元素)  作用就是返回该数组元素的索引号 从后面开始查找<br>如果这个元素在数组中不存在, 没找到, 返回 -1     </p>\n<p>数组去重 利用新数组.indexOf(数组元素) 如果返回 -1 就说明新数组 里面没有该元素<br>if (newArr.indexOf(arr[i]) === -1) {<br>newArr.push(arr[i])<br> }        数组去重(第六天)</p>\n<p>字符串对象  根据位置返回字符 :   ( 根据索引号获取参数)</p>\n<ol>\n<li> 字符串名 .charAt(index)<br>var str = ‘andy’<br>console.log(str.charAt(3));     // 写索引号 返回值为元素</li>\n<li> 字符串名.charCodeAt(index)  返回相应索引号的字符ASCII值 目的： 判断用户按下了那个键<br>console.log(str.charCodeAt(0));</li>\n<li>str[index]  H5 新增的<br>  console.log(str[0]);<br>console.log( str1.substring(1, 3)) ;        str1.substring(1, 3) 获取的是第1个元素到第二个 不包含第三个</li>\n</ol>\n<p>基本包装类型<br> var str = ‘andy’;<br>        console.log(str.length);   为什么能够使用length属性?</p>\n<pre><code>   1.将简单数据类型包装成复杂数据类型\n    var temp = new String(&#39;andy&#39;)\n    2.把临时变量的值 给str\n     str = temp\n</code></pre>\n<p> 3.销毁这个临时变量<br>         temp = null</p>\n<p>简单数据类型 是存在栈里面 里面直接开辟一个空间存放的是值 传参是把值结果传过去了<br>复杂数据类型 首先在栈里面存放地址 十六进制表示 然后这个地址指向堆里面的数据 ( 通过new字关键字创建的对象也就叫复杂数据类型)</p>\n<p>includes（） 包含的意思 如果有false返回false<br>Array (数组)  : 一种特别对象(数值下标)<br>=== / ==(会做数据转换)<br>console.log返回的数据类型是函数</p>\n<p>undefined 与 null的区别<br>undefined代表定义未赋值<br>null定义赋值了 只是值为null<br> 2. 什么时候给变量赋值为null<br>初始赋值,表明将要赋值的对象<br>结束前, 让对象成为垃圾对象<br>3. 严格区分变量类型与数据类型<br>数据的基本类型<br>基本类型  对象类型<br>变量的类型(变量内存值的类型)<br>      基本类型:保存的就是基本类型的数据<br>引用类型:保存的就是地址值</p>\n<p>不会改变原数组：</p>\n<pre><code> concat() 连接两个或更多数组，返回结果\nevery() 检测数组中每个元素是否都符合要求\nsome() 检测数组中是否有元素符合要求\nfilter() 挑选数组中符合条件的并返回符合要求的数组\njoin() 把数组的所有元素放到一个字符串\ntoString() 把数组转成字符串\nslice() 截取一段数组，返回新数组\nindexOf 搜索数组中的元素，并返回他所在的位置 \n</code></pre>\n<p>————————————————<br>会改变原数组：</p>\n<p>1 添加元素类：（返回新的长度）</p>\n<pre><code>push() 把元素添加到数组尾部\nunshift() 在数组头部添加元素\n</code></pre>\n<p>2 删除元素类：（返回的是被删除的元素）</p>\n<pre><code>pop() 移除数组最后一个元素\nshift() 删除数组第一个元素\n</code></pre>\n<p>3 颠倒顺序：</p>\n<pre><code>reverse() 在原数组中颠倒元素的顺序\n</code></pre>\n<p>4 插入、删除、替换数组元素：（返回被删除的数组）</p>\n<pre><code>splice(index, howmany, item1…intemx)\nindex代表要操作数组位置的索引值，必填\nhowmany 代表要删除元素的个数，必须是数字，可以是0，如果没填就是删除从index到数组的结尾\nitem1…intemx 代表要添加到数组中的新值\n</code></pre>\n<p>5 排序</p>\n<pre><code>sort() 对数组元素进行排序\n</code></pre>\n","categories":["JavaScript基础"]},{"title":"总结","url":"/2022/07/12/%E6%80%BB%E7%BB%93/","content":"<p>函数</p>\n<p>事件<br> div.addEventListener(‘click’, function(e) {<br>            // console.log(e.currentTarget)<br>            console.log(e)<br>            e.type // 事件类型<br>            e.target // 触发事件的元素, 点击的谁, 指向的是谁<br>            e.currentTarget // 绑定事件的元素 === this<br>            e.pageX<br>            e.pageY // 相对于页面文档的坐标</p>\n<pre><code>        e.keyCode // 返回ASCII码值, 可以通过它判断键盘按了哪个键\n        e.key\n        e.code                                              属性\n\n\n\n        e.preventDefault() // 阻止默认行为\n        e.stopPropagation() // 阻止事件冒泡           方法\n\n    &#125;)\n</code></pre>\n<p>数组<br>不会改变原数组：                                            方法</p>\n<pre><code> concat() 连接两个或更多数组，返回结果\nevery() 检测数组中每个元素是否都符合要求\nsome() 检测数组中是否有元素符合要求\nfilter() 挑选数组中符合条件的并返回符合要求的数组\njoin() 把数组的所有元素放到一个字符串\ntoString() 把数组转成字符串\nslice() 截取一段数组，返回新数组\nindexOf 搜索数组中的元素，并返回他所在的位置 \n</code></pre>\n<p>————————————————<br>会改变原数组：</p>\n<p>1 添加元素类：（返回新的长度）</p>\n<pre><code>push() 把元素添加到数组尾部\nunshift() 在数组头部添加元素\n</code></pre>\n<p>2 删除元素类：（返回的是被删除的元素）</p>\n<pre><code>pop() 移除数组最后一个元素\nshift() 删除数组第一个元素\n</code></pre>\n<p>3 颠倒顺序：</p>\n<pre><code>reverse() 在原数组中颠倒元素的顺序\n</code></pre>\n<p>4 插入、删除、替换数组元素：（返回被删除的数组）</p>\n<pre><code>splice(index, howmany, item1…intemx)\nindex代表要操作数组位置的索引值，必填\nhowmany 代表要删除元素的个数，必须是数字，可以是0，如果没填就是删除从index到数组的结尾\nitem1…intemx 代表要添加到数组中的新值\n</code></pre>\n<p>5 排序</p>\n<pre><code>sort() 对数组元素进行排序\n</code></pre>\n<p>数组名.length            属性</p>\n<p>数组去重:<br>indenxof  数组下标法<br>includes()<br>filter</p>\n<p>字符串</p>\n<p>.length                               属性</p>\n<p> concat  拼接数组    console.log(str.concat(‘456’));               方法<br> substring(star,end)  截取字符串   取不到end        console.log(str1.substring(0, 3));<br> 替换字符.replace(‘被替换的字符’,’要替换的字符’)       </p>\n<pre><code>    0 ,&#39;&#39;, null, undefined, NaN   返回布尔值\n</code></pre>\n","categories":["js总结小点"]},{"title":"webApi","url":"/2022/07/09/webApi/","content":"<p>事件基础<br>API :   application programming interface  :  应用程序编程接口.   API ==&gt; 接口<br>接口:  联想一下手机的接口, 我们可以通过它实现充电的功能, 我们不需要了解内部怎么实现这个功能的.<br>在我们程序里面, 接口 可以看作是 方法或者函数 或者 说工具. ,<br>比如 alert(),  它就是浏览器提供给我们的一个接口. 弹出一个警示框.<br>再比如说prompt(), 它也是一个接口.<br>Web API : 浏览器提供给我们的操作页面元素 和 浏览器功能 的 API  ( DOM,  BOM)<br>Web API = DOM  + BOM ;<br>DOM: document object model   文档对象模型,  一个页面就是一个文档, 把我们的页面看做一个对象.<br>顶级对象就是document..<br>BOM : browser object model 浏览器对象模型, 把我们的浏览器看做一个对象. 提供给我们一些方法, 操作浏览器的功能.<br>DOM作用: 通过DOM, 我们可以改变页面的内容 , 结构, 样式.<br>DOM树 : 代表了一种层级结构, 表示元素之间的一种层级关系 . 比如父子, 兄弟关系.<br>文档 : document  一个页面就是一个文档.<br>元素: element .  什么是元素: 页面上的所有标签都是元素.  h1 , div, span , script html.<br>节点: node   页面上所有的内容都叫节点.  (元素节点, 属性节点, 文本节点, 注释节点)</p>\n<p>getElements  加s的都是伪数组<br>document.getElementById(‘id’)     通过id名 获取元素<br>console.dir(id名)  打印返回我们的返回的元素 更好查看里面的属性和方法      返回的是一个对象</p>\n<p>document.getElementsByTagName(‘ol’)   返回带有指定标签的对象的集合  以伪数组的形式存储的   如果页面中没有这元素 返回的是个伪数组</p>\n<p> ol ( 父级元素名 ).getElementsByTagName(‘li  (子元素名) ‘)    获取某个元素(父级元素)内部所有指定标签名的子元素    也可以通过id的方式获取</p>\n<p>document.getElementsByClassName(‘box’)   通过类名获取元素 返回的是一个伪数组</p>\n<p>查<br>H5C3新增获取元素方法 （选择器需要加 .box   #nav） 推荐使用<br> document.querySelector(‘选择器’)    返回指定选择器的第一个元素对象<br> document.querySelectorAll(‘选择器’)     返回指定选择器的所有元素对象 返回的也是一个伪数组<br>如果页面没有这个标签，返回的是一个空的伪数组<br>  var lis4 = document.querySelectorAll(‘#nav li  ‘)     获取id名为nav里面所有的li标签</p>\n<p>总结获取元素的一些方法 API<br>ID: document.getElementById(‘’)    不用加#号<br>标签名:  document.getElementsByTagName(‘标签名’)    ==&gt;elements  返回的是一堆, 元素集合, 伪数组.<br>H5新增:<br>类名 :  document.getElementsByClassName(‘类名’)  ==&gt; 不加 ., 返回的也是元素集合, 伪数组. 一堆.<br>选择器:<br>document.querySelector(‘选择器’)    (类名 : .   id : #  标签)   ==&gt; 返回的是指定选择器的第一个元素对象.<br>document.querySelectorAll(‘选择器’)    (类名 : .   id : #  标签)    ==&gt; 返回的是一堆元素集合. 伪数组.</p>\n<p>特殊的两个<br>body : document.body<br>html  : document.documentElement</p>\n<p>事件<br> //  事件三要素 谁，触发了设什么，要做什么<br> // 1.事件源<br> // 2.事件类型<br> // 3.事件处理程序<br> btn.onclick  ==&gt; 点击才会调用函数. 点我们点击的时候, 才会去执行函数内部的代码<br>改变元素内容<br>element.innerText      非标准</p>\n<p>创建<br>element.innerHTML  最常用 是 w3c指定的  识别html标签 比如<strong><br>createElement 新建一个元素</p>\n<p>常用属性操作<br>表单里面的值是通过vaule修改的</p>\n<p>按钮设置可以点击多次 （密码小眼睛）</p>\n<p>通过js修改元素的大小，颜色，位置<br>1.element.style 行内样式操作<br>改<br>2.修改许多元素样式 element.ClassName    适用于样式较多或者功能较多的情况下使用  会覆盖以前的类名<br>（1） 先写一个css样式<br>让我们当前的元素改为 change    this.className =‘  change  ’<br>如果想不替换掉掉原来的类名  先将 this className = ‘ 原类名    现类名  ’</p>\n<p>循环精灵图 （通过for循环给各个li标签添加背景图片）</p>\n<p>显示隐藏文本框内容<br>获得焦点onfocus   失去焦点 onblur<br>onmouseover 鼠标经过     onmouseout鼠标离开<br>mosuedown 鼠标按下 mouseup 鼠标松开</p>\n<p>排他思想（如果有相同一组元素，我们想给某一个元素设置某种样式）&amp;点击一个 取消另外一个</p>\n<p> element.getAttribute()  获取类名里面的内容</p>\n<p>更改原来的属性名 （更改自定义） element.setAttribute( ‘属性’, ‘值’  )</p>\n<p>自定义属性：<br>以 data-xxx 开头, 直接写在标签上。<br>获取 data- 开头的自定义属性 element.dataset</p>\n<p>节点</p>\n<p>父节点 node.parentNode  / element.parentNode<br>获取到的是最近的一级父节点,如果找不到 返回null</p>\n<p>子节点 node.children   </p>\n<p>获取第一个子元素 node.firstElementChild<br>获取最后一个子元素 node.lastElementChild<br>获取第一个子节点 node.firstChild<br>获取最后一个子节点 node.lastChild</p>\n<p>兄弟节点</p>\n<p>增加<br>创建和添加节点<br>node.appendChid( 子元素 ) 添加到父级元素末尾<br>node.insertBefore( 子元素,指定元素的位置 )</p>\n<p>删<br>node(父级元素).removeChild(子元素)从dom中删除一个子节点,返回删除的节点   只能删除离父节点最近的一个子节点<br>node(将要被复制的元素).cloneNode()  克隆节点  克隆以后还要添加  括号为空或者false不会克隆里面的内容  括号里面加true就可以显示元素里面的内容<br>1.先获取要克隆的节点   2.克隆要克隆的节点  3.添加克隆的元素到某个位置 </p>\n<p>(btn.disabled = true)表示开启禁用</p>\n<p>事件高级<br>1.传统注册事件:<br> 特点:具有唯一性    同一个元素,同一件事只能处理一个函数,最后注册的处理函数将会覆盖前面注册的处理函数<br>事件对象：当某个事件触发的时候, 和这个事件相关的系列信息集合都放在这个event事件对象里面<br>2. 方法监听注册方式    addEventListener(‘click’，function（event （对象）   ）{<br>e.target(属性)<br>})  w3c推荐方式 </p>\n<p>(1)里面的事件类型是字符串 必定加引号 而且不带on<br>(2)同一个元素 同一件事件可以添加多个侦听器(事件处理程序)<br>排他思想          </p>\n<p> 传统注册事件       删除事件一定要解绑,写在函数里面<br>            btn.onclick = null<br> 事件监听解绑事件 .removeEventListener(‘click’,fn )  删除事件:当点击一次以后不需要调用 一定要写在函数里面</p>\n<p>DOM事件冒泡<br>事件捕获: 从外到内    冒泡:从内到外</p>\n<p>e.targrt 返回的是触发事件的对象(元素)      放在函数function() 里面</p>\n<p>e.targrt 和 this和e.currentTarget            e.targrt 返回的是触发事件的对象 也就是点的哪个就是哪个元素    this和e.currentTarget 哪个元素绑定了这个点击事件,那么就返回谁<br>e.currentTarget 全等 this </p>\n<p>e.type指的是返回事件类型 比如 返回 click<br> e.preventDefault();   阻止默认行为事件 让链接不跳转 或者让提交按钮不提及      return false 也可以阻止链接跳转<br>阻止冒泡 e.stopPropagation()  </p>\n<p>事件委托原理  利用事件冒泡,将事件监听设置在父节点上 通过父节点来监听子节点的事件<br>优点:只操作一次DOM ,提高程序性能(只需要绑定一次)    动态创建的子元素,也拥有注册事件</p>\n<p>常用的鼠标事件(了解)  配合e.preventDefault();阻止默认行为<br>1.禁止鼠标右键菜单 contextmenu<br>2. selectstart 禁止鼠标选中    </p>\n<p>鼠标移动事件<br>mousemove</p>\n<p>键盘事件</p>\n<p>keypress 会区分大小写<br>keyup =&gt; keydown =&gt; keypress<br>     // input.focus() 获得焦点<br>        // input.blur() 失去焦点</p>\n<p>BOM<br>窗口加载事件<br>传统方式  window.onload = function(){}  把元素写在里面以后 可以将js代码写到任意位置  只能写一次<br>使用addEventListener则没有限制</p>\n<p>页面加载事件window.addEventListener()<br>// load 事件:当页面所有内容加载完之后,包括css js 图片等 执行的回调函数</p>\n<p>DOMContentLoaded : DOM 元素加载完成以后,执行回调函数,此时, css , js, img 还没加载完<br>通过这个页面加载事件,我们可以将js代码写在head里面<br>DOMContentLoaded 实际应用场景 : 当一个页面图片特别多的时候 ,我们希望早一点执行js代码时,可以使用DOMContentLoaded做来监听  </p>\n<p>resize  浏览器窗口大小的监听<br>window.innerWidth  获取当前浏览器窗口的大小</p>\n<p>定时器<br> 1.window.setTimeout(调用函数, 延迟时间)  只执行一次单位为毫秒</p>\n<p>可以用变量存起来</p>\n<p>清除定时器:  window.clearTimeout(timeoutId)   写在函数里面    </p>\n<p>window.setInterval(func, delay)</p>\n<p>this 在定义的时候不能确定，只有在执行的时候才能确定它的指向！！！！<br>全局作用域中/普通函数调用/定时器里面， this 指向 window<br>函数方法调用中，谁调用这个方法，this指向谁<br> 事件注册的时候， this指向被绑定的元素<br>构造函数中，this指向的是构造函数的实例<br>类里面的指向问题:<br>constructor 里面的this指向的是创建的对象的实例<br>类里面方法中this 指向的是这个方法的调用者</p>\n<p>//! 1. JS是单线程语言<br>// 同一时间只能做一件事情(同步), 所有的任务都顺序执行.<br>//! 2. 线程 和 进程<br>// Q: 什么是线程 什么是进程?<br>// 进程是资源分配的最小单位,线程是cup调度的最小单位. 太抽象了,不好理解.<br>// 进程(process) : 一个进程就是一个正在运行的程序.(任务管理器)<br>// 线程(thread) : 一个进程内执行着的每个任务就是一个线程.<br>//                线程是允许应用程序并发执行多个任务的一个机制.<br>// 简单的比如 进程 = 火车  线程 = 车厢<br>// 1. 线程必须依附于进程存在<br>// 2. 一个进程可以包含多个线程 (一个火车里面有多个车厢)<br>//! 3 同步 和 异步<br>// 同步: 同一时间只能做一件事情(同步), 所有的任务都顺序执行, 上一个任务执行完,才执行下一个任务.<br>// 异步: 可以同一时间执行多个任务. 提高了程序的执行效率(并发执行)</p>\n<pre><code>    // 加了一个异步进程的概念 : 处理什么时候把回调函数写入任务队列\n    // setTimeout\n    // 注册事件  click 等事件 会交给 异步进程处理\n\n    // 同步任务: 同步仍无都在主线程上执行, 形成一个执行栈\n    // 异步任务: 异步任务是通过回调函数来完成的.\n\n    // 一般而言，异步任务有以下三种类型：\n    // 普通事件，如click，resize等\n    // 资源加载，如load，DOMContentLoaded等\n    // 定时器，包括setTimeout，setInterval等\n    // 其实就是那些回调函数\n\n    // JS执行机制 **** 理解记忆, 重点!\n    // 要求记下这块\n    // 1. 我们先判断JS任务是同步任务还是异步任务, 所有的同步任务都放入主线程的执行栈中执行.\n    // 2. 异步任务会提交给异步进程处理, 当满足触发条件后, 异步进程会将异步任务(回调函数)放入任务队列中.\n    // 3. 当主线程中所有的(所有的,所有的)同步任务执行完后, 会去任务队列中查找是否有可执行的异步任务, 如果有, 拿到主线程中执行,\n    //  执行完后, 再去任务队列中查找. 不断循环这样一个过程. \n    // Event loop .&#39;\n\n\n\n    // 以后面试会考! 90%  记下来 ! \n    // 事件循环 event loop \n    // 异步任务 : 又分为 宏任务 (macroTask) 和 微任务 (microTask)\n    // 宏任务 : \n    // 1. 整个script代码块\n    // 2. setTimeout\n    // 3. setInterval\n    // 4. setImmediate\n\n    // 微任务 : \n    // 1. promise.then() / promise.catch()\n    // 2. process.nextTick (node)\n    // 3. async await   \n    // 4. mutationObserver \n\n    // ==&gt;  ! 每执行完一个宏任务, 会清空(执行完所有的)当前的微任务队列. \n</code></pre>\n<p>元素偏移量  offset<br>1.element. offsetTOP  element. offsetLeft   元素相对于body的距离     如果这个元素有父元素 也是相当于body的距离  如果想得到这个元素相对于父级元素的距离 则要给父级元素设置定位<br>2..ement. offsetWidth ement. offsetHeight 得到元素的大小 宽度 高度 是包含border和padding<br>style.width和offsetWidth的区别：<br>style.width 获取到的值是不包padding和border 只能获取行内样式中的width  可以修改样式<br> offsetWidth 获得的是包含width+ border +padding  得到的值没有像素单位  可以得到任何样式中的值</p>\n<p>3..element. offsetPartent 返回带有定位的父级元素 否则返回body</p>\n<p>获取页面滚动距离 : window.pageYOffset </p>\n<p>client系列<br>1.element.clientTop 返回元素上边框的大小  .element.clientLeft 返回元素左边框的大小<br>2..element.clientWidth 返回自身包括padding和内容区域宽度 不包含边框  element.clientWidth 返回自身包括padding和内容区域高度 不包含边框</p>\n<p>立即执行函数<br>function fn () {  console.log(‘sddas’)  }   fn()<br>( function (){} )()   或者 (function(){}())</p>\n<p>scroll  系列 元素滚动<br>1.scrollHeight 实际内容的大小  不含边框<br>2.element.scrollTop   返回元素被卷去的头部 和 scrollLeft搭配使用</p>\n<p>页面被卷曲的头部 window.pageYOffset 获得被卷去的头部的高度<br>mouseenter mouseleave没有事件冒泡<br>动画函数封装 （通过定时器setinterval()不断移动盒子位置）</p>\n<pre><code>  window.scroll(&#123;\n            top: 0,\n            behavior: &#39;smooth&#39;\n        &#125;)       平滑滚动到顶部\n</code></pre>\n<p>移动端</p>\n<ol>\n<li>e.touches    正在触摸屏幕的所有手指的列表信息(伪数组)</li>\n<li>e.targetTouches  正在触摸当前dom元素的手指列表信息</li>\n<li>e.changedTouches 手指状态发生了改变时的手指列表信息</li>\n</ol>\n<p>产生300ms延迟的原因<br>由于移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，<br>看用户有没有下一次点击，也就是这次操作是不是双击</p>\n<p>不能存储对象数组 只能存储字符串的格式    </p>\n<p>添加类名 element.classList.add(‘类名’)         注意不要加类名的符号 . 不会影响到其他类名 在后面追加<br>删除类名element.classList.remove()<br>切换类名 element.classList.toggle() </p>\n","categories":["webApi"]},{"title":"首页","url":"/2022/07/13/%E9%A6%96%E9%A1%B5/","content":"<p>网站前端<br>前端技术一般分为前端设计和前端开发，前端设计一般可以理解为网站的视觉设计，前端开发则是网站的前台代码实现，包括基本的HTML和CSS以及JavaScript/ajax，最新的高级版本HTML5、CSS3，以及SVG等。<br>核心技术<br>HTML、CSS、JavaScript<br>这三个是前端开发中最基本也是最必须的三个技能。前端的开发中，在页面的布局时， HTML将元素进行定义，CSS对展示的元素进行定位，再通过JavaScript实现相应的效果和交互。虽然表面看起来很简单，但这里面需要掌握的东西绝对不会少。在进行开发前，需要对这些概念弄清楚、弄明白，这样在开发的过程中才会得心应手。<br>HTML<br>指的是超文本标记语言 (Hyper Text Markup Language)，这个也是我们网页最常用普通的语言了，经历了多个版本的发展，已经发展到5.0版了，得力于W3C建立的标准和规范，已普遍升级到了XHTML，XHTML 指可扩展超文本标签语言（EXtensible HyperText Markup Language）， XHTML 于2000年的1月26日成为 W3C 标准，是更严格更纯净的 HTML 代码，XHTML 的目标是取代 HTML。XHTML 与 HTML 4.01 几乎是相同的，XHTML 是作为一种 XML 应用被重新定义的 HTML，是一个 W3C 标准。W3C 将 XHTML 定义为最新的HTML版本。所有新的浏览器都支持 XHTML。<br>CSS<br>级联样式表（Cascading Style Sheet）简称“CSS”，通常又称为“风格样式表（Style Sheet）”，它是用来进行网页风格设计的。比如，如果想让链接字未点击时是蓝色的，当鼠标移上去后字变成红色的且有下划线，这就是一种风格。通过设立样式表，可以统一地控制HTML中各标志的显示属性。级联样式表可以使人更能有效地控制网页外观。使用级联样式表，可以扩充精确指定网页元素位置，外观以及创建特殊效果的能力。<br>JavaScript<br>是一种由Netscape的LiveScript发展而来的原型化继承的面向对象的动态类型的区分大小写的客户端脚本语言，主要目的是为了解决服务器端语言，比如Perl，遗留的速度问题，为客户提供更流畅的浏览效果。当时服务端需要对数据进行验证，由于网络速度相当缓慢，只有28.8kbps，验证步骤浪费的时间太多。于是Netscape的浏览器Navigator加入了Javascript，提供了数据验证的基本功能。</p>\n","categories":["首页"]},{"title":"HTML&CSS","url":"/2022/07/11/HTML&CSS/","content":"<p>html:<br>1、表格：跨行rowspan 跨列 colspan 去掉表格缝隙：rules=”all” caption 表单标题<br>2、表单：单选框radio name属性值设置一样即可单选一个  复选框 checkbox 当checkbox=checkbox的时候即为默认选择&lt;input type=”file” multiple实现文件的多选&gt; 文本框最大长度：maxlength=”” 默认输入：placeholder<br>3、文本域：textarea:palceholder(默认值)</p>\n<p>多个块元素纵向排列找标准流，多个块级元素横向排列找浮动。浮动只会影响后面的标准流不会影响前面的标准流</p>\n<p>css:<br>1、div两个盒子移动中间那个盒子导致两个一起移动解决方案:可以为父元素定义上边框，可以为父元素定义上内边距，可给父元素添加overflow:hidden<br>2、块级元素使其水平居中 margin:0 auto； 行内块和行元素水平居中直接给父元素添加text-algin:center<br>3、图片超过div盒子解决方案：img{width:100%}<br>4、圆角边框：border-radius:50%  border-top-right-radius 右上角          border-buttom-right-radius:右下角</p>\n<p>5、盒子（文字）添加阴影：（text）box-shahow:h-shahow（水平阴影）v-shahow（垂直阴影） blur（模糊距离）spread（阴影的尺寸）box-shadow:10px 10px 10px 10px rgba(0,0,0,.3)<br>6、所有元素添加浮动元素以后都会有行内块的一些特性，块级元素没有设置宽度和父级元素一样宽，添加浮动元素以后大小是由里面的内容决定的<br>7、有宽度，margin才会居中<br>8、.box&gt;div {} 只选择一个div<br>9、不方便给父级盒子高度便清除高度<br>10、清除浮动：clear：left right both<br>11、Cursor:pointer 让鼠标变成小手<br>12、p标签里面不放H<br>13、h标签不会继承父级元素的大小，a标签不会继承父级的颜色 div不会继承父级的背景颜色<br>14、导航栏是通过li+a的做法<br>15、导航栏里面的文字不一样多，不给宽度，用padding撑开左右边距 给padding一个左右的值（不给元素宽度，添加一个pandding便不会使元素的盒子变大）（a里面的文字，使用padding使其左右有距离）<br>16、文本框里面的文字距离边框有距离，可以使用padding<br>17、行内块有空白缝隙·<br>18、减掉盒子的内外边距使盒子加边距不会变大 新增css3:box-sizing: border-box;就不用减掉<br>18.内边距:给容器加,控制内部的元素. 外边距:给自己加,控制的是自身于别的元素的距离<br>19.外边距合并水平方向不会合并只有垂直的时候,解决办法:将其中的一个盒子使用margin-botton/将上面的盒子转换为行内块模式<br>20.定位分为static静态定位 (了解) relative 相对定位 (相对之前的位置移动,移动以后之前的位置保留)    absolute 绝对定位(不占据原来位置) fixed 固定定位:跟随版心移动:<br>固定定位 left:50% margin-left : 版心的一半 盒子如果要放在左边 那么值就给相反的right值<br>粘性定位:sticky :保留位置 当拉到可视距离就可以移动  以浏览器的可视窗口为参照点移动元素</p>\n<p>c3盒子模型： 边框、外边距、内边距、和实际内容<br>z-index数值越大越往上<br>21.<br>div::after    div::before          day6 伪元素<br>display:none  隐藏 display:block 显示 占有原来的位置  配合js使用<br>visibility:visible 可视元素  visibility:hidden 隐藏 不再占有原来位置<br>22.精灵图 往上走和往左走数值是负的(一般情况下)<br>23.三角形的做法 箭头朝就给下边框, 箭头朝哪边就给相反方向的边框 其余边框为零</p>\n<p>24.cirsor:pointer 鼠标变小手  default 默认 move 移动 text 文本  not-allowd 禁止<br>25.outline:none 去掉表单的轮廓框          文本域防止拖拽: resize:none (文本域尽的标签尽量放在同一排)<br>26.vertical-align:midden 图片和文垂直居中 只能使用在行内元素或者行内块元素   图片加上div会显示有空白缝隙 加上vertical其中任何一个值都可以去掉<br>27.单行文本溢出显示省略号的三个条件:white-space:nowrap(强制一行内显示文本)  overflow:hidden(超出部分隐藏)   text-overflow:ellipsis (文字超出部分使用省略号进行替代) 哪里需要放哪里<br>多行文本溢出显示省略号<br>-webkit-line-clamp: 3;<br>display: -webkit-box;<br>-webkit-box-orient: vertical;<br>overflow: hidden;<br>text-overflow: ellipsis;</p>\n<p> /* 让所有文字都正常自动换行 */<br>            word-break: break-all;</p>\n<p>28.margin:-1 可以去掉重合的盒子的边框重复问题但是鼠标经过的效果会导致一边的边框显示不出来 解决方案:1.添加相对定位即可.2若果有相对定位即给父元素添加定位 给当前的元素添加 z-index层级<br>文字环绕图片</p>\n<p>29.等腰三角形的做法</p>\n<p>30.清除浮动</p>\n<p>元素加浮动,绝对定位以后都可以设置元素的大小<br>31.不透明度 opacity:0.5 取值在0-1之间      0完全透明 1完全不透明   容器会全部变化 opacity 可以搭配hover搭配过渡效果使用<br>32.细线边框：border-collapse:collapse</p>\n<p>34.图片模糊:filter:blur(5px) 数值越大 图片越模糊<br>伪元素是行内元素 必须写connet<br>padding 给文字  margin给容器<br>min-width设置最小的缩放距离<br>35.object-fit:cover 让当前元素自动填充,删减两边内容进行填充<br>36.transform：translate  移动       不会影响其他盒子</p>\n<p>实现盒子垂直居中  配合定位<br>rotate  旋转    后面跟单位deg   </p>\n<p> Scale缩放<br>37.动画<br>@keyframes 动画时间 {<br>/* 开始状态 <em>.<br>0% (from) {<br>transfrom:translateX( 0px);<br>}<br>100%(to) {<br>transfrom:translate X(1000px);<br>}<br>}<br>类名 {<br>/</em> 里面必须包含 *<br>/* 调用动画 *<br>/* 动画名称*<br>animation-name:动画名称;<br>/<em>持续时间</em><br>animation-duration:2s;<br>}</p>\n<p>38.透视<br>透视写到被观察盒子的父级元素 perspective:像素; 透视越小盒子越大 透视越小越立体 通常距离是800-1200<br>39.3d旋转 rotade<br>40.3d呈现 transform-style：preserve-3d写在父级 影响的子元素</p>\n<p>web移动端<br>1.<br>弹性定位<br>flex-direction:colum设置主轴Y           (默认主轴为row即x轴)<br>2.flex-warp：warp 让子元素换行<br>3.align-content：center 多行设置居中 单行没有效果<br>4.flex-flow：row warp  复合写法<br>5.order：-1； 默认是0 比0小所以排列在前<br>        display: flex;<br>        /* 默认从终点依次对齐 <em>/<br>        justify-content: flex-end;<br>        /</em> 默认从起点依次排列 <em>/<br>        justify-content: start;<br>        /</em> 让内部元素居中排列 <em>/<br>        justify-content: center;<br>        /</em> 空白间距均分在子元素的两侧  视觉效果：起点和终点窄 中间宽 <em>/<br>        justify-content: space-around;<br>        /</em> 元素1在起始位置，最后一个元素在终点位置，剩下的空间均分 <em>/<br>        justify-content: space-between;<br>        /</em> 弹性盒子与容器之间的间距相等 */<br>        justify-content: space-evenly;</p>\n<p>移动适配：网页内容（盒子、文本、图片）自适应屏幕尺寸，在不同的移动设备下，让网页达到一个合理的展示</p>\n<p>2.字号为14px的大小 行高设置成1.5最好<br>3.媒体查询  @mediatype screen     and (max-width:800px;) {<br>body {<br>banckground-color:pink;<br>}<br>}<br>          当屏幕最大的宽度不超过800px时 背景颜色为粉色</p>\n<p>less<br>1.定义一个粉色的变量<br>@color:pink;<br>引用变量<br>body {<br>background-color:@color;<br>}<br>2.     .box{<br>width:100px;<br>height:100px;<br>background-color:pink;<br>a {<br>font-size:14px;<br>如果有伪类元素、交集选择器、伪元素选择器则在前面加上&amp;<br>&amp;：：after {<br>font-size:20px;<br>}<br>}<br>}    定义大盒子以及盒子里面的子元素</p>\n<ol start=\"3\">\n<li>Less可加减乘除  除需要用./或者（）包起来  中间的加减乘除符号必须和数字用空格隔开否则不生效<br>.box {<br>    margin: 100px auto;<br>    background-color: aquamarine;<br>    // width: 100px - 50px;<br>    height: 200px - 100px;<br>    width: (800px / 2px);<br>    height: (1000px * 2px);<br>    width: 500px - 200px;<br>}</li>\n</ol>\n<p>(function flexible (window, document) {<br>  var docEl = document.documentElement<br>  var dpr = window.devicePixelRatio || 1</p>\n<p>  // adjust body font size<br>  function setBodyFontSize () {<br>    if (document.body) {<br>      document.body.style.fontSize = (12 * dpr) + ‘px’<br>    }<br>    else {<br>      document.addEventListener(‘DOMContentLoaded’, setBodyFontSize)<br>    }<br>  }<br>  setBodyFontSize();</p>\n<p>  // set 1rem = viewWidth / 10<br>  function setRemUnit () {<br>    var rem = docEl.clientWidth / 10<br>    docEl.style.fontSize = rem + ‘px’<br>  }</p>\n<p>  setRemUnit()</p>\n<p>  // reset rem unit on page resize<br>  window.addEventListener(‘resize’, setRemUnit)<br>  window.addEventListener(‘pageshow’, function (e) {<br>    if (e.persisted) {<br>      setRemUnit()<br>    }<br>  })</p>\n<p>  // detect 0.5px supports<br>  if (dpr &gt;= 2) {<br>    var fakeBody = document.createElement(‘body’)<br>    var testElement = document.createElement(‘div’)<br>    testElement.style.border = ‘.5px solid transparent’<br>    fakeBody.appendChild(testElement)<br>    docEl.appendChild(fakeBody)<br>    if (testElement.offsetHeight === 1) {<br>      docEl.classList.add(‘hairlines’)<br>    }<br>    docEl.removeChild(fakeBody)<br>  }<br>}(window, document))</p>\n<p>保证px-rem的基准值为设计稿的375px一样  加入js文件  实现web适配 自适应变大变小文字和盒子都会改变</p>\n<p>vw<br>// 百分比和vw的区别<br>// 百分比相对于父级元素的宽度<br>// 1vw指的是永远对视口的百分之一，和父容器的宽度无关    </p>\n<p>// vw方案与rem对比<br>// rem的适配原理较为复杂<br>// vw适配较简单<br>// rem需要js引用<br>// vw不需要引用js 自动获取</p>\n<p>// vw相对单位  相对视口（当前设备的屏幕尺寸）<br>// 1vw相对于视口屏幕的百分之一<br> 响应式</p>\n<!-- 响应式基本要素 -->\n<p>    <!-- 1.页面随屏幕尺寸变化而变化 2.网址没有变化，代表同一个页面 3.网页内容没有变化，容器结构的样式变化--><br>    <!-- 总结 --><br>    <!-- 网站只有一套代码，根据不同的设备尺寸，不同的特性对页面的内容样式进行相应的调整 --><br>    <!-- 优缺点 --><br>    <!-- 灵活性强,能较为快捷的解决多尺寸屏幕的适配问题 --><br>    <!-- 缺点：工作量大 难以维护 无用代码过多 加载时间长 各个设备兼容 也代表没有一个设备尺寸是完美的 属于折中方案 --></p>\n<p>框架</p>\n<!-- 什么是框架? -->\n<!-- 一套完整的方案,有自己的结构体系,定义了体系的流程及规则,预定义了很多东西,用户可根据需求去使用 -->\n<!-- 现阶段的理解: -->\n<!-- 经过多年的发展,发现前端页面中很多样式功能都很普遍,有团队把这些效果抽离出来,别人需要用的时候,直接 -->\n<!-- 使用 -->\n<!-- 本质: -->\n<!-- 不让简单且繁琐的内容过多的占据了开发人员的时间与精力,把更多的精力放在业务的逻辑处理上 -->\n\n<p>ps<br>当文字和图片不在同一层时使用Ctrl+e合并图层再导出<br>2、透明文件导出要用png</p>\n<p>px em rem的区别<br>P x: 表示固定的像素单位<br>E m: 相对单位, 相对于当前容器的字体大小而定,常用于首行缩进2个字符等<br>rem: 相对单位, 相对于当前根标签html的字体大小,1rem = 1html的字体大小<br>V W: 相对单位, 1vw等于视口宽度的百分之一<br>V H: 相对单位, 1vh等于视口高度的百分之一</p>\n<p>flex<br>块级元素和行内元素变成弹性盒子后,宽度和高度默认不写时,分别会发生什么变化?<br>答:<br>块级元素变成弹性盒子后,宽度由父级百分比变为由内容撑开,高度不设置时,默认拉伸铺满父容器的高度.<br>行内元素变成弹性盒子后,可直接设置宽高,内容由内容撑开,高度不设置时,默认拉伸铺满父容器的高度.<br>flex:1到底是什么:<br>flex实际上是flex-grow、flex-shrink和flex-basis三个属性的缩写。</p>\n<p>background-size: cover把背景图扩展至足够大，直至完全覆盖背景区域，图片比例保持不变且不会失真，但某些部分被切割无法显示完整背景图像<br>部分UI库<br>vant<br><a href=\"https://vant-contrib.gitee.io/vant-weapp/#/home\">https://vant-contrib.gitee.io/vant-weapp/#/home</a><br>element<br><a href=\"https://element.eleme.cn/#/zh-CN\">https://element.eleme.cn/#/zh-CN</a><br>uivew<br><a href=\"https://www.uviewui.com/components/text.html\">https://www.uviewui.com/components/text.html</a><br>ivew<br><a href=\"https://iview.github.io/components/table\">https://iview.github.io/components/table</a></p>\n","categories":["HTML&CSS基础"]}]